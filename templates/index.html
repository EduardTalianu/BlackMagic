<!doctype html>
<title>Kali-LLM Task Manager</title>
<style>
body{font-family:Arial;margin:1rem;height:95vh}
.container{display:flex;gap:20px;height:100%}
.left-column{flex:1;display:flex;flex-direction:column;max-width:400px}
.right-column{flex:3;display:flex;flex-direction:column}
textarea{width:100%;resize:none;margin-bottom:10px}
button{margin:5px 0;padding:5px 10px;width:100%}
#status{margin:10px 0;font-weight:bold}
h2{margin-top:0}
.tabs{display:flex;border-bottom:1px solid #ccc}
.tab{padding:10px 15px;cursor:pointer;background:#f1f1f1;border:1px solid #ccc;border-bottom:none;margin-right:5px}
.tab.active{background:#fff;border-bottom:1px solid #fff;margin-bottom:-1px}
.tab-content{display:none;padding:10px;border:1px solid #ccc;border-top:none;flex:1;overflow-y:auto}
.tab-content.active{display:flex;flex-direction:column}
#work_dir{background:#f9f9f9;font-family:monospace;white-space:pre-wrap}
.file-item{padding:5px;border-bottom:1px solid #eee;cursor:pointer}
.file-item:hover{background:#f0f0f0}
.file-item.directory{font-weight:bold}
.file-actions{display:flex;gap:10px;margin-top:5px}
.file-actions button{padding:2px 8px;font-size:12px;width:auto}
.file-content{background:#f5f5f5;padding:10px;margin-top:5px;border:1px solid #ddd}
.input-container{flex:1;display:flex;flex-direction:column}
.controls-container{display:flex;gap:10px;margin-top:10px}
.controls-container button{flex:1}
.info-box{background:#e8f4f8;padding:10px;margin-bottom:10px;border-radius:5px}
.path-nav{background:#f0f0f0;padding:5px;margin-bottom:10px;border-radius:5px}
.path-nav button{padding:2px 8px;font-size:12px;width:auto;margin:0 2px}
.shared-info{background:#e8f8e8;padding:10px;margin-bottom:10px;border-radius:5px}
.config-section{background:#fff3cd;padding:10px;margin-bottom:10px;border-radius:5px;border:1px solid #ffc107}
.config-controls{display:flex;gap:10px;align-items:center;margin-top:5px}
.config-controls input{padding:5px;width:80px}
.config-controls button{padding:5px 15px;width:auto}
.translation-section{background:#e3f2fd;padding:10px;margin-bottom:10px;border-radius:5px;border:1px solid #2196f3;display:none}
.translation-section.active{display:block}
.translation-content{background:#fff;padding:10px;margin-top:10px;border-radius:5px;border:1px solid #ccc;max-height:200px;overflow-y:auto}
.translation-field{margin-bottom:10px}
.translation-field strong{display:block;color:#1976d2;margin-bottom:5px}
.translation-field div{color:#424242;white-space:pre-wrap}
#askInput{height:120px}
.workflow-status{background:#f5f5f5;padding:8px;margin:10px 0;border-left:3px solid #2196f3;font-size:0.9em}
.task-item{padding:10px;margin:5px 0;border:1px solid #ddd;border-radius:5px;cursor:pointer}
.task-item:hover{background:#f9f9f9}
.task-item.pending{border-left:4px solid #ffc107}
.task-item.planning{border-left:4px solid #2196f3}
.task-item.working{border-left:4px solid #ff9800}
.task-item.completed{border-left:4px solid #4caf50}
.task-item.failed{border-left:4px solid #f44336}
.task-item.cancelled{border-left:4px solid #9e9e9e}
.task-header{display:flex;justify-content:space-between;align-items:center}
.task-id{font-family:monospace;color:#666;font-size:0.9em}
.task-status{font-weight:bold;padding:2px 8px;border-radius:3px;font-size:0.85em}
.task-status.pending{background:#fff3cd;color:#856404}
.task-status.planning{background:#cfe2ff;color:#084298}
.task-status.working{background:#fff3cd;color:#664d03}
.task-status.completed{background:#d1e7dd;color:#0f5132}
.task-status.failed{background:#f8d7da;color:#842029}
.task-status.cancelled{background:#e2e3e5;color:#41464b}
.mode-selector{background:#e8f5e9;padding:10px;margin-bottom:10px;border-radius:5px;border:1px solid #4caf50}
.mode-selector label{display:block;margin:5px 0;cursor:pointer}
.mode-selector input[type="radio"]{margin-right:8px}
.mermaid-container{width:100%;height:100%;overflow:auto}
</style>
<div class="container">
  <div class="left-column">
    <h2>Task Input</h2>
    
    <div class="mode-selector">
      <strong>üéØ Execution Mode</strong>
      <label><input type="radio" name="mode" value="hierarchical" checked> Hierarchical (Auto-split into sub-tasks)</label>
      <label><input type="radio" name="mode" value="legacy"> Legacy (Step-by-step with manual continue)</label>
    </div>
    
    <div class="config-section" id="legacyConfig" style="display:none">
      <strong>Auto-Continue Settings</strong>
      <div class="config-controls">
        <label>Delay (seconds):</label>
        <input type="number" id="delayInput" value="10" min="1" max="60">
        <button id="updateConfig" style="width:auto">Update</button>
      </div>
    </div>
    
    <div class="translation-section" id="translationSection">
      <strong>üìã Translated Task</strong>
      <div class="translation-content" id="translationContent">
        <div class="translation-field">
          <strong>Abstract:</strong>
          <div id="taskAbstract"></div>
        </div>
        <div class="translation-field">
          <strong>Description:</strong>
          <div id="taskDescription"></div>
        </div>
        <div class="translation-field">
          <strong>Verification:</strong>
          <div id="taskVerification"></div>
        </div>
      </div>
    </div>
    
    <div class="input-container">
      <form id="form">
        <label>What do you want to accomplish?</label><br>
        <textarea id="askInput" placeholder="Example:&#10;1. Perform passive recon on domain example.com&#10;2. Scan a web application for vulnerabilities&#10;3. Enumerate SMB shares on 192.168.1.0/24"></textarea><br>
        <div class="controls-container">
          <button type="button" id="translateBtn">Translate Task</button>
          <button type="submit" id="startBtn" disabled>Start Execution</button>
          <button type="button" id="continue" style="display:none">Continue</button>
          <button type="button" id="reset">Reset</button>
        </div>
      </form>
      <div class="workflow-status" id="workflowStatus" style="display:none"></div>
      <div id="status"></div>
    </div>
  </div>
  
  <div class="right-column">
    <h2>Output</h2>
    <div class="tabs">
      <div class="tab active" data-tab="task_status">Task Status</div>
      <div class="tab" data-tab="graph_view">Task Graph</div>
      <div class="tab" data-tab="terminal_output">Terminal Output</div>
      <div class="tab" data-tab="llm_output">LLM Responses</div>
      <div class="tab" data-tab="work_dir">Work Directory</div>
    </div>
    
    <div id="task_status" class="tab-content active">
      <div style="margin-bottom:10px">
        <button id="refreshTasks" style="width:auto;padding:5px 15px">üîÑ Refresh Tasks</button>
        <span id="taskCount" style="margin-left:10px;color:#666"></span>
      </div>
      <div id="taskList">Loading tasks...</div>
    </div>
    
    <div id="graph_view" class="tab-content">
      <div style="margin-bottom:10px">
        <label>Task ID: </label>
        <input type="text" id="graphTaskId" placeholder="Enter task ID" style="width:150px;padding:5px">
        <button id="loadGraph" style="width:auto;padding:5px 15px">Load Graph</button>
        <button id="autoRefreshGraph" style="width:auto;padding:5px 15px;margin-left:10px">Auto-Refresh: OFF</button>
      </div>
      <div class="mermaid-container" id="mermaidContainer">
        <div style="color:#999;text-align:center;padding:20px">Enter a task ID and click "Load Graph" to view the task execution tree</div>
      </div>
    </div>
    
    <div id="terminal_output" class="tab-content">
      <div style="margin-bottom:10px">
        <label>Task ID: </label>
        <input type="text" id="terminalTaskId" placeholder="Enter task ID" style="width:150px;padding:5px">
        <button id="loadTerminal" style="width:auto;padding:5px 15px">Load Output</button>
        <button id="autoRefreshTerminal" style="width:auto;padding:5px 15px;margin-left:10px">Auto-Refresh: OFF</button>
      </div>
      <div id="terminalContent" style="background:#000;color:#0f0;font-family:monospace;white-space:pre-wrap;padding:10px;height:calc(100% - 60px);overflow-y:auto">
        No terminal output loaded. Enter a task ID and click "Load Output".
      </div>
    </div>
    
    <div id="llm_output" class="tab-content">
      <div style="margin-bottom:10px">
        <label>Task ID: </label>
        <input type="text" id="llmTaskId" placeholder="Enter task ID" style="width:150px;padding:5px">
        <button id="loadLLM" style="width:auto;padding:5px 15px">Load Responses</button>
        <button id="autoRefreshLLM" style="width:auto;padding:5px 15px;margin-left:10px">Auto-Refresh: OFF</button>
      </div>
      <div id="llmContent" style="background:#1a1a1a;color:#ff0;font-family:monospace;white-space:pre-wrap;padding:10px;height:calc(100% - 60px);overflow-y:auto">
        No LLM responses loaded. Enter a task ID and click "Load Responses".
      </div>
    </div>
    
    <div id="work_dir" class="tab-content">
      <div class="shared-info">
        <strong>Shared Directories:</strong>
        <div id="sharedInfo">Loading...</div>
      </div>
      <div class="path-nav">
        <span id="currentPath">/app</span>
        <button id="parentDirBtn" style="display:none">‚Üë Parent</button>
      </div>
      <div id="file_list">Loading...</div>
      <div id="file_content"></div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({ startOnLoad: false, theme: 'default' });

// DOM Elements
const terminalContent=document.getElementById('terminalContent');
const llmContent=document.getElementById('llmContent');
const task_status=document.getElementById('task_status');
const graph_view=document.getElementById('graph_view');
const work_dir=document.getElementById('work_dir');
const file_list=document.getElementById('file_list');
const file_content=document.getElementById('file_content');
const status=document.getElementById('status');
const form=document.getElementById('form');
const startBtn=document.getElementById('startBtn');
const continueBtn=document.getElementById('continue');
const resetBtn=document.getElementById('reset');
const currentPath=document.getElementById('currentPath');
const parentDirBtn=document.getElementById('parentDirBtn');
const sharedInfo=document.getElementById('sharedInfo');
const delayInput=document.getElementById('delayInput');
const updateConfig=document.getElementById('updateConfig');
const askInput=document.getElementById('askInput');
const translateBtn=document.getElementById('translateBtn');
const translationSection=document.getElementById('translationSection');
const taskAbstract=document.getElementById('taskAbstract');
const taskDescription=document.getElementById('taskDescription');
const taskVerification=document.getElementById('taskVerification');
const workflowStatus=document.getElementById('workflowStatus');
const taskList=document.getElementById('taskList');
const refreshTasks=document.getElementById('refreshTasks');
const taskCount=document.getElementById('taskCount');
const graphTaskId=document.getElementById('graphTaskId');
const loadGraph=document.getElementById('loadGraph');
const autoRefreshGraph=document.getElementById('autoRefreshGraph');
const terminalTaskId=document.getElementById('terminalTaskId');
const loadTerminal=document.getElementById('loadTerminal');
const autoRefreshTerminal=document.getElementById('autoRefreshTerminal');
const llmTaskId=document.getElementById('llmTaskId');
const loadLLM=document.getElementById('loadLLM');
const autoRefreshLLM=document.getElementById('autoRefreshLLM');
const mermaidContainer=document.getElementById('mermaidContainer');
const legacyConfig=document.getElementById('legacyConfig');

// State Variables
let currentDirPath = '/app';
let autoContDelay = 10;
let countdownTimer = null;
let countdownSeconds = 0;
let translatedTask = null;
let currentTaskId = null;
let currentMode = 'hierarchical';
let pollingInterval = null;
let graphAutoRefresh = false;
let terminalAutoRefresh = false;
let llmAutoRefresh = false;
let graphRefreshInterval = null;
let terminalRefreshInterval = null;
let llmRefreshInterval = null;

// Mode selector
document.querySelectorAll('input[name="mode"]').forEach(radio => {
  radio.addEventListener('change', (e) => {
    currentMode = e.target.value;
    legacyConfig.style.display = currentMode === 'legacy' ? 'block' : 'none';
    
    if (currentMode === 'hierarchical') {
      document.querySelector('.tab[data-tab="task_status"]').click();
    } else {
      document.querySelector('.tab[data-tab="terminal_output"]').click();
    }
  });
});

// Load configuration
async function loadConfig(){
  try {
    const r=await fetch('/config');
    const data=await r.json();
    autoContDelay=data.auto_continue_delay;
    delayInput.value=autoContDelay;
  } catch (e) {
    console.error('Failed to load config:', e);
  }
}

// Update configuration
updateConfig.onclick=async()=>{
  try {
    const newDelay=parseInt(delayInput.value);
    if(newDelay < 1 || newDelay > 60){
      alert('Delay must be between 1 and 60 seconds');
      return;
    }
    const r=await fetch('/config',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({auto_continue_delay:newDelay})
    });
    const data=await r.json();
    autoContDelay=data.auto_continue_delay;
    status.textContent=`‚úì Auto-continue delay updated to ${autoContDelay} seconds`;
  } catch (e) {
    status.textContent=`‚úó Failed to update config: ${e.message}`;
  }
};

// Tab functionality
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab).classList.add('active');
    
    if (tab.dataset.tab === 'work_dir') {
      loadSharedInfo();
      loadFiles(currentDirPath);
    } else if (tab.dataset.tab === 'task_status') {
      loadAllTasks();
    }
  });
});

// Keyboard shortcuts
askInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && e.ctrlKey) {
    e.preventDefault();
    if(translatedTask){
      startTask();
    } else {
      translateTask();
    }
  }
});

// Button handlers
translateBtn.onclick=async()=>{
  await translateTask();
};

form.onsubmit=async(e)=>{
  e.preventDefault();
  if(translatedTask){
    await startTask();
  } else {
    status.textContent='‚ö†Ô∏è Please translate the task first';
  }
};

continueBtn.onclick=async()=>{
  clearCountdown();
  await continueTask();
};

resetBtn.onclick=async()=>{
  clearCountdown();
  stopAllRefresh();
  await fetch('/reset',{method:'POST'});
  terminalContent.textContent='';
  status.textContent='Session reset. Ready for new task.';
  workflowStatus.style.display='none';
  continueBtn.style.display='none';
  startBtn.disabled = true;
  translatedTask = null;
  translationSection.classList.remove('active');
  translateBtn.disabled = false;
  currentTaskId = null;
  stopPolling();
};

parentDirBtn.onclick=async()=>{
  if(currentDirPath !== '/'){
    const parentPath = currentDirPath.split('/').slice(0, -1).join('/') || '/';
    await navigateToDirectory(parentPath);
  }
};

refreshTasks.onclick=async()=>{
  await loadAllTasks();
};

// Auto-refresh controls
loadGraph.onclick=async()=>{
  const taskId = graphTaskId.value.trim();
  if (!taskId) {
    status.textContent = '‚ö†Ô∏è Please enter a task ID';
    return;
  }
  await loadTaskGraph(taskId);
};

autoRefreshGraph.onclick=()=>{
  toggleAutoRefresh('graph');
};

loadTerminal.onclick=async()=>{
  const taskId = terminalTaskId.value.trim();
  if (!taskId) {
    status.textContent = '‚ö†Ô∏è Please enter a task ID';
    return;
  }
  await loadTerminalOutput(taskId);
};

autoRefreshTerminal.onclick=()=>{
  toggleAutoRefresh('terminal');
};

loadLLM.onclick=async()=>{
  const taskId = llmTaskId.value.trim();
  if (!taskId) {
    status.textContent = '‚ö†Ô∏è Please enter a task ID';
    return;
  }
  await loadLLMOutput(taskId);
};

autoRefreshLLM.onclick=()=>{
  toggleAutoRefresh('llm');
};

function toggleAutoRefresh(type){
  if(type === 'graph'){
    graphAutoRefresh = !graphAutoRefresh;
    autoRefreshGraph.textContent = graphAutoRefresh ? 'Auto-Refresh: ON' : 'Auto-Refresh: OFF';
    autoRefreshGraph.style.background = graphAutoRefresh ? '#4caf50' : '';
    autoRefreshGraph.style.color = graphAutoRefresh ? '#fff' : '';
    
    if(graphAutoRefresh){
      const taskId = graphTaskId.value.trim();
      if(taskId){
        graphRefreshInterval = setInterval(()=>loadTaskGraph(taskId), 3000);
      }
    } else {
      if(graphRefreshInterval){
        clearInterval(graphRefreshInterval);
        graphRefreshInterval = null;
      }
    }
  } else if(type === 'terminal'){
    terminalAutoRefresh = !terminalAutoRefresh;
    autoRefreshTerminal.textContent = terminalAutoRefresh ? 'Auto-Refresh: ON' : 'Auto-Refresh: OFF';
    autoRefreshTerminal.style.background = terminalAutoRefresh ? '#4caf50' : '';
    autoRefreshTerminal.style.color = terminalAutoRefresh ? '#fff' : '';
    
    if(terminalAutoRefresh){
      const taskId = terminalTaskId.value.trim();
      if(taskId){
        terminalRefreshInterval = setInterval(()=>loadTerminalOutput(taskId), 3000);
      }
    } else {
      if(terminalRefreshInterval){
        clearInterval(terminalRefreshInterval);
        terminalRefreshInterval = null;
      }
    }
  } else if(type === 'llm'){
    llmAutoRefresh = !llmAutoRefresh;
    autoRefreshLLM.textContent = llmAutoRefresh ? 'Auto-Refresh: ON' : 'Auto-Refresh: OFF';
    autoRefreshLLM.style.background = llmAutoRefresh ? '#4caf50' : '';
    autoRefreshLLM.style.color = llmAutoRefresh ? '#fff' : '';
    
    if(llmAutoRefresh){
      const taskId = llmTaskId.value.trim();
      if(taskId){
        llmRefreshInterval = setInterval(()=>loadLLMOutput(taskId), 3000);
      }
    } else {
      if(llmRefreshInterval){
        clearInterval(llmRefreshInterval);
        llmRefreshInterval = null;
      }
    }
  }
}

function stopAllRefresh(){
  if(graphRefreshInterval){
    clearInterval(graphRefreshInterval);
    graphRefreshInterval = null;
  }
  if(terminalRefreshInterval){
    clearInterval(terminalRefreshInterval);
    terminalRefreshInterval = null;
  }
  if(llmRefreshInterval){
    clearInterval(llmRefreshInterval);
    llmRefreshInterval = null;
  }
  graphAutoRefresh = false;
  terminalAutoRefresh = false;
  llmAutoRefresh = false;
  autoRefreshGraph.textContent = 'Auto-Refresh: OFF';
  autoRefreshGraph.style.background = '';
  autoRefreshGraph.style.color = '';
  autoRefreshTerminal.textContent = 'Auto-Refresh: OFF';
  autoRefreshTerminal.style.background = '';
  autoRefreshTerminal.style.color = '';
  autoRefreshLLM.textContent = 'Auto-Refresh: OFF';
  autoRefreshLLM.style.background = '';
  autoRefreshLLM.style.color = '';
}

function clearCountdown(){
  if(countdownTimer){
    clearInterval(countdownTimer);
    countdownTimer=null;
  }
}

function startCountdown(seconds, callback){
  clearCountdown();
  countdownSeconds=seconds;
  
  const updateStatus=()=>{
    if(countdownSeconds > 0){
      status.innerHTML=`‚è∏Ô∏è Task in progress... <span style="color:#666;font-size:0.9em;font-style:italic">Auto-continuing in ${countdownSeconds}s</span>`;
      countdownSeconds--;
    } else {
      clearCountdown();
      callback();
    }
  };
  
  updateStatus();
  countdownTimer=setInterval(updateStatus, 1000);
}

async function translateTask(){
  const userRequest=askInput.value.trim();
  if(!userRequest) {
    status.textContent='‚ö†Ô∏è Please enter a task description';
    return;
  }
  
  translateBtn.disabled = true;
  status.textContent='üîÑ Translating task...';
  workflowStatus.style.display='block';
  workflowStatus.textContent='Step 1/2: Translating user request into structured task...';
  
  try {
    const r=await fetch('/translate',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({request:userRequest})
    });
    
    const data=await r.json();
    
    if(data.error){
      status.textContent=`‚ùå Translation failed: ${data.error}`;
      workflowStatus.style.display='none';
      translateBtn.disabled = false;
      return;
    }
    
    translatedTask = data.translated_task;
    
    taskAbstract.textContent = translatedTask.abstract;
    taskDescription.textContent = translatedTask.description;
    taskVerification.textContent = translatedTask.verification;
    translationSection.classList.add('active');
    
    startBtn.disabled = false;
    status.textContent='‚úÖ Task translated successfully! Click "Start Execution" to begin.';
    workflowStatus.textContent='Step 1/2: ‚úì Task translated. Ready for execution.';
    
  } catch (e) {
    status.textContent=`‚ùå Translation error: ${e.message}`;
    workflowStatus.style.display='none';
    translateBtn.disabled = false;
  }
}

async function startTask(){
  if(!translatedTask){
    status.textContent='‚ö†Ô∏è Please translate the task first';
    return;
  }
  
  if (currentMode === 'hierarchical') {
    await startHierarchicalTask();
  } else {
    await startLegacyTask();
  }
}

async function startHierarchicalTask(){
  clearCountdown();
  status.textContent='‚è≥ Creating task...';
  workflowStatus.style.display='block';
  workflowStatus.textContent='Step 2/2: Creating hierarchical task execution...';
  startBtn.disabled = true;
  translateBtn.disabled = true;
  
  try {
    const r=await fetch('/task',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({translated_task:translatedTask})
    });
    
    const data=await r.json();
    
    if(data.error){
      status.textContent=`‚ùå Failed to create task: ${data.error}`;
      workflowStatus.style.display='none';
      startBtn.disabled = false;
      return;
    }
    
    currentTaskId = data.task_id;
    graphTaskId.value = currentTaskId;
    terminalTaskId.value = currentTaskId;
    llmTaskId.value = currentTaskId;
    
    status.textContent=`‚úÖ Task created: ${currentTaskId}. Executing in background...`;
    workflowStatus.textContent=`Step 2/2: Task ${currentTaskId} is now executing. Switch to Terminal Output or LLM Responses tabs to monitor.`;
    
    // Immediately load the task list to show it
    console.log('[UI] Task created, loading task list...');
    await loadAllTasks();
    
    document.querySelector('.tab[data-tab="terminal_output"]').click();
    
    // Enable all auto-refresh
    graphAutoRefresh = true;
    autoRefreshGraph.textContent = 'Auto-Refresh: ON';
    autoRefreshGraph.style.background = '#4caf50';
    autoRefreshGraph.style.color = '#fff';
    graphRefreshInterval = setInterval(()=>loadTaskGraph(currentTaskId), 3000);
    
    terminalAutoRefresh = true;
    autoRefreshTerminal.textContent = 'Auto-Refresh: ON';
    autoRefreshTerminal.style.background = '#4caf50';
    autoRefreshTerminal.style.color = '#fff';
    terminalRefreshInterval = setInterval(()=>loadTerminalOutput(currentTaskId), 3000);
    
    llmAutoRefresh = true;
    autoRefreshLLM.textContent = 'Auto-Refresh: ON';
    autoRefreshLLM.style.background = '#4caf50';
    autoRefreshLLM.style.color = '#fff';
    llmRefreshInterval = setInterval(()=>loadLLMOutput(currentTaskId), 3000);
    
    startPolling(currentTaskId);
    
  } catch (e) {
    console.error('[UI] Error creating task:', e);
    status.textContent=`‚ùå Error: ${e.message}`;
    workflowStatus.style.display='none';
    startBtn.disabled = false;
  }
}

async function startLegacyTask(){
  clearCountdown();
  terminalContent.textContent='';
  status.textContent='‚è≥ Processing...';
  workflowStatus.style.display='block';
  workflowStatus.textContent='Step 2/2: Executing task...';
  continueBtn.style.display='none';
  startBtn.disabled = true;
  translateBtn.disabled = true;
  
  document.querySelector('.tab[data-tab="terminal_output"]').click();
  
  const r=await fetch('/run',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({
      ask:askInput.value.trim(),
      translated_task:translatedTask
    })
  });
  const data=await r.json();
  updateLegacyUI(data);
}

async function continueTask(){
  status.textContent='‚è≥ Processing...';
  continueBtn.style.display='none';
  
  const r=await fetch('/run',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({continue:true})
  });
  const data=await r.json();
  updateLegacyUI(data);
}

function updateLegacyUI(data){
  if(data.error){
    clearCountdown();
    terminalContent.textContent+=`\n‚ùå Error: ${data.error}`;
    status.textContent='‚ùå Task failed';
    startBtn.disabled = false;
    return;
  }
  
  terminalContent.textContent+=data.output+'\n\n';
  terminalContent.scrollTop = terminalContent.scrollHeight;
  
  if(data.done){
    clearCountdown();
    if(data.summary){
      terminalContent.textContent+=`\n\n‚úÖ Task completed: ${data.summary}`;
    }
    status.textContent='‚úÖ Task completed';
    workflowStatus.textContent='Step 2/2: ‚úì Task execution completed successfully!';
    continueBtn.style.display='none';
    startBtn.disabled = true;
    translateBtn.disabled = false;
    translatedTask = null;
  } else {
    const delay=data.auto_continue_delay || autoContDelay;
    continueBtn.style.display='inline-block';
    workflowStatus.textContent='Step 2/2: Task execution in progress...';
    
    if(data.auto_continue){
      startCountdown(delay, continueTask);
    } else {
      status.textContent='‚è∏Ô∏è Task in progress... (click Continue)';
    }
  }
}

async function loadAllTasks(){
  try {
    const r=await fetch('/task/status');
    const data=await r.json();
    
    console.log('[UI] Task status response:', data);
    
    if(data.error){
      taskList.textContent=`Error: ${data.error}`;
      return;
    }
    
    if(!data.tasks || data.tasks.length === 0){
      taskList.innerHTML='<div style="color:#999;text-align:center;padding:20px">No tasks yet. Create a task to get started.</div>';
      taskCount.textContent='';
      return;
    }
    
    console.log('[UI] Total entries:', data.tasks.length);
    
    // Separate root tasks and nodes
    const rootTasks = data.tasks.filter(t => t.type === 'root');
    const nodes = data.tasks.filter(t => t.type === 'node');
    
    console.log('[UI] Root tasks:', rootTasks.length, 'Nodes:', nodes.length);
    
    taskCount.textContent=`Total tasks: ${rootTasks.length}, Total nodes: ${nodes.length}`;
    
    taskList.innerHTML='';
    
    if(rootTasks.length === 0){
      taskList.innerHTML='<div style="color:#999;text-align:center;padding:20px">No tasks found (but we have data). Check console for debug info.</div>';
      console.log('[UI] All task entries:', data.tasks);
      return;
    }
    
    // Display each root task with its nodes
    rootTasks.forEach(task => {
      const taskItem=document.createElement('div');
      taskItem.className=`task-item ${task.status}`;
      taskItem.innerHTML=`
        <div class="task-header">
          <span class="task-id">üéØ ${task.task_id}</span>
          <span class="task-status ${task.status}">${task.status.toUpperCase()}</span>
        </div>
        <div style="margin-top:5px;font-weight:bold">${task.abstract}</div>
        <div style="margin-top:5px;font-size:0.9em;color:#666">${task.created_at}</div>
      `;
      taskItem.onclick=()=>viewTaskDetails(task.task_id);
      taskList.appendChild(taskItem);
      
      // Add child nodes
      const taskNodes = nodes.filter(n => n.task_id === task.task_id);
      if(taskNodes.length > 0){
        taskNodes.forEach(node => {
          const nodeItem=document.createElement('div');
          nodeItem.className=`task-item ${node.status}`;
          nodeItem.style.marginLeft='30px';
          nodeItem.style.borderLeft='3px solid #ccc';
          nodeItem.innerHTML=`
            <div class="task-header">
              <span class="task-id">üì¶ ${node.node_id}</span>
              <span class="task-status ${node.status}">${node.status.toUpperCase()}</span>
            </div>
            <div style="margin-top:5px">${node.abstract}</div>
            <div style="margin-top:5px;font-size:0.8em;color:#666">${node.created_at}</div>
          `;
          nodeItem.onclick=(e)=>{
            e.stopPropagation();
            viewNodeDetails(node.node_id);
          };
          taskList.appendChild(nodeItem);
        });
      }
    });
  } catch (e) {
    console.error('[UI] Error loading tasks:', e);
    taskList.textContent=`Error loading tasks: ${e.message}`;
  }
}

async function viewNodeDetails(nodeId){
  // For now, just show in status
  status.textContent=`Viewing node: ${nodeId}`;
  // TODO: Load node-specific outputs
}

async function viewTaskDetails(taskId){
  try {
    const r=await fetch(`/task/${taskId}`);
    const data=await r.json();
    
    if(data.error){
      status.textContent=`Error: ${data.error}`;
      return;
    }
    
    graphTaskId.value = taskId;
    terminalTaskId.value = taskId;
    llmTaskId.value = taskId;
    
    await loadTaskGraph(taskId);
    await loadTerminalOutput(taskId);
    await loadLLMOutput(taskId);
    
    document.querySelector('.tab[data-tab="graph_view"]').click();
    
  } catch (e) {
    status.textContent=`Error: ${e.message}`;
  }
}

async function loadTaskGraph(taskId){
  try {
    const r=await fetch(`/tree?task_id=${encodeURIComponent(taskId)}`);
    const data=await r.json();
    
    if(data.error){
      mermaidContainer.innerHTML=`<div style="color:#f44336;padding:20px">${data.error}</div>`;
      return;
    }
    
    mermaidContainer.innerHTML=`<div class="mermaid">${data.graph}</div>`;
    mermaid.init(undefined, mermaidContainer.querySelector('.mermaid'));
    
  } catch (e) {
    mermaidContainer.innerHTML=`<div style="color:#f44336;padding:20px">Error loading graph: ${e.message}</div>`;
  }
}

async function loadTerminalOutput(taskId){
  try {
    const r=await fetch(`/task/${taskId}`);
    const data=await r.json();
    
    if(data.error){
      terminalContent.textContent=`Error: ${data.error}`;
      return;
    }
    
    if(!data.terminal_output || data.terminal_output.length === 0){
      terminalContent.textContent='No terminal output yet. Task may still be planning or just started.';
      return;
    }
    
    terminalContent.textContent = data.terminal_output.join('\n');
    terminalContent.scrollTop = terminalContent.scrollHeight;
    
  } catch (e) {
    terminalContent.textContent=`Error loading terminal output: ${e.message}`;
  }
}

async function loadLLMOutput(taskId){
  try {
    const r=await fetch(`/task/${taskId}`);
    const data=await r.json();
    
    if(data.error){
      llmContent.textContent=`Error: ${data.error}`;
      return;
    }
    
    if(!data.llm_responses || data.llm_responses.length === 0){
      llmContent.textContent='No LLM responses yet. Task may still be initializing.';
      return;
    }
    
    let formatted = data.llm_responses.map((resp, idx) => {
      return `[${idx + 1}] ${resp}`;
    }).join('\n\n' + '='.repeat(80) + '\n\n');
    
    llmContent.textContent = formatted;
    llmContent.scrollTop = llmContent.scrollHeight;
    
  } catch (e) {
    llmContent.textContent=`Error loading LLM output: ${e.message}`;
  }
}

function startPolling(taskId){
  stopPolling();
  
  // Also poll the task list to keep it updated
  const taskListRefresh = setInterval(()=>loadAllTasks(), 5000);
  
  pollingInterval=setInterval(async()=>{
    try {
      const r=await fetch(`/task/${taskId}`);
      const data=await r.json();
      
      if(!data.error && (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled' || data.status === 'impossible')){
        stopPolling();
        stopAllRefresh();
        clearInterval(taskListRefresh);
        
        await loadTerminalOutput(taskId);
        await loadLLMOutput(taskId);
        await loadTaskGraph(taskId);
        
        status.textContent=`Task ${taskId}: ${data.status}`;
        if(data.result){
          status.textContent+=` - ${data.result}`;
        }
        
        loadAllTasks();
      }
    } catch (e) {
      console.error('Polling error:', e);
    }
  }, 3000);
}

function stopPolling(){
  if(pollingInterval){
    clearInterval(pollingInterval);
    pollingInterval=null;
  }
}

async function loadSharedInfo(){
  try {
    const r=await fetch('/shared_info');
    const data=await r.json();
    
    if(data.error){
      sharedInfo.textContent=`Error: ${data.error}`;
      return;
    }
    
    sharedInfo.innerHTML=`
      <div>Container Work Dir: ${data.work_directory}</div>
      <div>Container Logs Dir: ${data.logs_directory}</div>
      <div>Host Work Dir: ${data.host_work_directory}</div>
      <div>Host Logs Dir: ${data.host_logs_directory}</div>
    `;
  } catch (e) {
    sharedInfo.textContent=`Error loading shared info: ${e.message}`;
  }
}

async function navigateToDirectory(path){
  currentDirPath = path;
  currentPath.textContent = path;
  parentDirBtn.style.display = path === '/' ? 'none' : 'inline-block';
  await loadFiles(path);
}

async function loadFiles(path){
  file_list.textContent='Loading...';
  file_content.innerHTML='';
  
  try {
    const r=await fetch(`/files?path=${encodeURIComponent(path)}`);
    const data=await r.json();
    
    if(data.error){
      file_list.textContent=`Error: ${data.error}`;
      return;
    }
    
    file_list.innerHTML='';
    
    if(data.files.length === 0){
      file_list.textContent='No files in this directory';
      return;
    }
    
    data.files.forEach(file => {
      const fileItem=document.createElement('div');
      fileItem.className=`file-item ${file.type}`;
      fileItem.innerHTML=`
        <div>${file.type === 'directory' ? 'üìÅ' : 'üìÑ'} ${file.name}</div>
        <div>Size: ${file.size} | Permissions: ${file.permissions}</div>
        <div class="file-actions">
          <button onclick="copyPath('${file.full_path}')">Copy Path</button>
          ${file.type === 'directory' ? `<button onclick="navigateToDirectory('${file.full_path}')">Enter</button>` : `<button onclick="viewFile('${file.full_path}')">View Content</button>`}
        </div>
      `;
      file_list.appendChild(fileItem);
    });
  } catch (e) {
    file_list.textContent=`Error loading files: ${e.message}`;
  }
}

function copyPath(path){
  navigator.clipboard.writeText(path).then(() => {
    status.textContent=`Copied path: ${path}`;
  }).catch(err => {
    status.textContent=`Failed to copy path: ${err}`;
  });
}

async function viewFile(path){
  file_content.innerHTML=`Loading content of ${path}...`;
  
  try {
    const r=await fetch(`/file?path=${encodeURIComponent(path)}`);
    const data=await r.json();
    
    if(data.error){
      file_content.innerHTML=`Error: ${data.error}`;
      return;
    }
    
    const contentDiv=document.createElement('div');
    contentDiv.className='file-content';
    contentDiv.innerHTML=`
      <h3>${path}</h3>
      <div style="display:flex;justify-content:space-between;margin-bottom:10px">
        <button onclick="copyFileContent('${path}')">Copy Content</button>
        <button onclick="file_content.innerHTML=''">Close</button>
      </div>
      <pre>${data.content}</pre>
    `;
    file_content.innerHTML='';
    file_content.appendChild(contentDiv);
  } catch (e) {
    file_content.innerHTML=`Error loading file: ${e.message}`;
  }
}

function copyFileContent(path){
  const content=document.querySelector('#file_content pre').textContent;
  navigator.clipboard.writeText(content).then(() => {
    status.textContent=`Copied content of ${path}`;
  }).catch(err => {
    status.textContent=`Failed to copy content: ${err}`;
  });
}

// Initialize on page load
window.addEventListener('load', () => {
  loadConfig();
  loadAllTasks();
  document.querySelector('.tab[data-tab="task_status"]').click();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  stopPolling();
  stopAllRefresh();
});
</script>